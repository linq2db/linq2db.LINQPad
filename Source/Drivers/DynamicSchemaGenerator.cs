using LINQPad.Extensibility.DataContext;
using LinqToDB.CodeModel;
using LinqToDB.Data;
using LinqToDB.Metadata;
using LinqToDB.Naming;
using LinqToDB.Scaffold;
using LinqToDB.Schema;

namespace LinqToDB.LINQPad;

internal static class DynamicSchemaGenerator
{
	private static ScaffoldOptions GetOptions(Settings settings, string? contextNamespace, string contextName)
	{
		var options = ScaffoldOptions.Default();

		var dontPluralize  = settings.ConnectionInfo.DynamicSchemaOptions.NoPluralization;
		var dontCapitalize = settings.ConnectionInfo.DynamicSchemaOptions.NoCapitalization;

		// set schema load options
		options.Schema.IncludeSchemas = settings.IncludeSchemas;
		foreach (var schema in (settings.Schemas ?? (IEnumerable<string>)Array.Empty<string>()))
			options.Schema.Schemas.Add(schema);

		options.Schema.IncludeCatalogs = settings.IncludeCatalogs;
		foreach (var catalog in (settings.Catalogs ?? (IEnumerable<string>)Array.Empty<string>()))
			options.Schema.Catalogs.Add(catalog);

		options.Schema.LoadedObjects = SchemaObjects.Table | SchemaObjects.View;

		if (settings.LoadForeignKeys       ) options.Schema.LoadedObjects |= SchemaObjects.ForeignKey;
		if (settings.LoadProcedures        ) options.Schema.LoadedObjects |= SchemaObjects.StoredProcedure;
		if (settings.LoadTableFunctions    ) options.Schema.LoadedObjects |= SchemaObjects.TableFunction;
		if (settings.LoadScalarFunctions   ) options.Schema.LoadedObjects |= SchemaObjects.ScalarFunction;
		if (settings.LoadAggregateFunctions) options.Schema.LoadedObjects |= SchemaObjects.AggregateFunction;

		options.Schema.PreferProviderSpecificTypes = settings.UseProviderTypes;
		options.Schema.IgnoreDuplicateForeignKeys  = false;
		options.Schema.UseSafeSchemaLoad           = false;
		options.Schema.LoadDatabaseName            = false;
		options.Schema.LoadProceduresSchema        = true;
		options.Schema.EnableSqlServerReturnValue  = true;

		// set data model options
		if (dontCapitalize)
			options.DataModel.EntityColumnPropertyNameOptions.Casing = NameCasing.None;
		if (dontPluralize)
			options.DataModel.EntityContextPropertyNameOptions.Pluralization = Pluralization.None;
		if (dontPluralize)
			options.DataModel.TargetMultipleAssociationPropertyNameOptions.Pluralization = Pluralization.None;

		options.DataModel.GenerateDefaultSchema              = true;
		options.DataModel.GenerateDataType                   = true;
		options.DataModel.GenerateDbType                     = true;
		options.DataModel.GenerateLength                     = true;
		options.DataModel.GeneratePrecision                  = true;
		options.DataModel.GenerateScale                      = true;
		options.DataModel.HasDefaultConstructor              = false;
		options.DataModel.HasConfigurationConstructor        = false;
		options.DataModel.HasUntypedOptionsConstructor       = false;
		options.DataModel.HasTypedOptionsConstructor         = false;
		options.DataModel.ContextClassName                   = contextName;
		options.DataModel.BaseContextClass                   = "LinqToDB.LINQPad.LINQPadDataConnection";
		options.DataModel.GenerateAssociations               = true;
		options.DataModel.GenerateAssociationExtensions      = false;
		options.DataModel.AssociationCollectionType          = "System.Collections.Generic.List<>";
		options.DataModel.MapProcedureResultToEntity         = true;
		options.DataModel.TableFunctionReturnsTable          = true;
		options.DataModel.GenerateProceduresSchemaError      = false;
		options.DataModel.SkipProceduresWithSchemaErrors     = true;
		options.DataModel.GenerateProcedureResultAsList      = false;
		options.DataModel.GenerateProcedureParameterDbType   = true;
		options.DataModel.GenerateProcedureSync              = true;
		options.DataModel.GenerateProcedureAsync             = false;
		options.DataModel.GenerateSchemaAsType               = false;
		options.DataModel.GenerateIEquatable                 = false;
		options.DataModel.GenerateFindExtensions             = DataModel.FindTypes.None;
		options.DataModel.OrderFindParametersByColumnOrdinal = true;

		// set code generation options
		options.CodeGeneration.EnableNullableReferenceTypes  = false;
		options.CodeGeneration.SuppressMissingXmlDocWarnings = true;
		options.CodeGeneration.MarkAsAutoGenerated           = false;
		options.CodeGeneration.ClassPerFile                  = false;
		options.CodeGeneration.Namespace                     = contextNamespace;

		return options;
	}

	public static (List<ExplorerItem> items, string sourceCode, IReadOnlyList<string> references) GetModel(
		Settings    settings,
		ref string? contextNamespace,
		ref string  contextName)
	{

		var providerName     = settings.Provider;
		var connectionString = settings.ConnectionInfo.DatabaseInfo.CustomCxString;
		var providerPath     = settings.ProviderPath;
		var commandTimeout   = settings.CommandTimeout;

		var scaffoldOptions  = GetOptions(settings, contextNamespace, contextName);

		var providerInfo     = ProviderHelper.GetProvider(providerName, providerPath);
		var provider         = providerInfo.GetDataProvider(connectionString);
		var references       = new List<string>(providerInfo.GetAssemblyLocation(connectionString));

		using var db         = new DataConnection(provider, connectionString)
		{
			CommandTimeout = commandTimeout
		};

		var sqlBuilder       = db.DataProvider.CreateSqlBuilder(db.MappingSchema);
		var language         = LanguageProviders.CSharp;
		var interceptor      = new ModelProviderInterceptor(sqlBuilder);
		var generator        = new Scaffolder(language, HumanizerNameConverter.Instance, scaffoldOptions, interceptor);
		var schemaProvider   = new LegacySchemaProvider(db, scaffoldOptions.Schema, language);
		var dataModel        = generator.LoadDataModel(schemaProvider, schemaProvider);

		var files = generator.GenerateCodeModel(
			sqlBuilder,
			dataModel,
			MetadataBuilders.GetAttributeBasedMetadataBuilder(generator.Language, sqlBuilder),
			SqlBoolEqualityConverter.Create(generator.Language),
			new DataModelAugmentor(language, language.TypeParser.Parse<LINQPadDataConnection>(), commandTimeout));

		// IMPORTANT:
		// real identifiers from generated code set to data model only after this line (GenerateSourceCode call)
		// so we call GetTree or read identifiers from dataModel.DataContext.Class before this line
		var sourceCode   = generator.GenerateSourceCode(dataModel, files)[0].Code;

		contextNamespace = dataModel.DataContext.Class.Namespace;
		contextName      = dataModel.DataContext.Class.Name;

		return (interceptor.GetTree(), sourceCode, references);
	}
}
