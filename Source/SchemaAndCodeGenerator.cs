using CodeJam.Strings;
using CodeJam.Xml;
using LINQPad.Extensibility.DataContext;
using LinqToDB.CodeModel;
using LinqToDB.Data;
using LinqToDB.Metadata;
using LinqToDB.Naming;
using LinqToDB.Scaffold;
using LinqToDB.Schema;

namespace LinqToDB.LINQPad;

static class ModelGenerator
{
	private static ScaffoldOptions GetOptions(IConnectionInfo cxInfo, string? contextNamespace, string contextName)
	{
		// TODO: add IConnectionInfo wrapper
		var options = ScaffoldOptions.Default();

		var dontPluralize = cxInfo.DynamicSchemaOptions.NoPluralization;
		var dontCapitalize = cxInfo.DynamicSchemaOptions.NoCapitalization;


		var includedSchemas = (string?)cxInfo.DriverData.Element(CX.IncludeSchemas);
		var excludedSchemas = (string?)cxInfo.DriverData.Element(CX.ExcludeSchemas);
		options.Schema.IncludeSchemas = includedSchemas != null;
		foreach (var schema in (includedSchemas ?? excludedSchemas ?? string.Empty).Split(',', ';'))
			options.Schema.Schemas.Add(schema);

		var includedCatalogs = (string?)cxInfo.DriverData.Element(CX.IncludeCatalogs);
		var excludedCatalogs = (string?)cxInfo.DriverData.Element(CX.ExcludeCatalogs);
		options.Schema.IncludeCatalogs = includedCatalogs != null;
		foreach (var catalog in (includedCatalogs ?? excludedCatalogs ?? string.Empty).Split(',', ';'))
			options.Schema.Catalogs.Add(catalog);

		var excludeRoutines = (string?)cxInfo.DriverData.Element(CX.ExcludeRoutines) == "false";
		var loadKeys = (string?)cxInfo.DriverData.Element(CX.ExcludeFKs) != "true";

		options.Schema.LoadedObjects = SchemaObjects.Table | SchemaObjects.View;
		if (loadKeys)
			options.Schema.LoadedObjects |= SchemaObjects.ForeignKey;
		if (!excludeRoutines)
			options.Schema.LoadedObjects |= SchemaObjects.StoredProcedure | SchemaObjects.AggregateFunction | SchemaObjects.ScalarFunction | SchemaObjects.TableFunction;

		var useProviderSpecificTypes = ((string?)cxInfo.DriverData.Element(CX.UseProviderSpecificTypes))?.ToLower() == "true";

		options.Schema.PreferProviderSpecificTypes = useProviderSpecificTypes;
		options.Schema.IgnoreDuplicateForeignKeys = false;
		options.Schema.UseSafeSchemaLoad = false;
		options.Schema.LoadDatabaseName = false;
		options.Schema.LoadProceduresSchema = true;
		options.Schema.EnableSqlServerReturnValue = true;
		options.DataModel.GenerateDefaultSchema = true;
		if (dontCapitalize)
			options.DataModel.EntityColumnPropertyNameOptions.Casing = NameCasing.None;
		if (dontPluralize)
			options.DataModel.EntityContextPropertyNameOptions.Pluralization = Naming.Pluralization.None;
		options.DataModel.GenerateDataType = true;
		options.DataModel.GenerateDbType = true;
		options.DataModel.GenerateLength = true;
		options.DataModel.GeneratePrecision = true;
		options.DataModel.GenerateScale = true;
		options.DataModel.HasDefaultConstructor = false;
		options.DataModel.HasConfigurationConstructor = false;
		options.DataModel.HasUntypedOptionsConstructor = false;
		options.DataModel.HasTypedOptionsConstructor = false;
		options.DataModel.ContextClassName = contextName;
		options.DataModel.BaseContextClass = "LinqToDB.LINQPad.LINQPadDataConnection";
		if (dontPluralize)
			options.DataModel.TargetMultipleAssociationPropertyNameOptions.Pluralization = Naming.Pluralization.None;
		options.DataModel.GenerateAssociations = true;
		options.DataModel.GenerateAssociationExtensions = false;
		options.DataModel.AssociationCollectionType = "System.Collections.Generic.List<>";
		options.DataModel.MapProcedureResultToEntity = true;
		options.DataModel.TableFunctionReturnsTable = true;
		options.DataModel.GenerateProceduresSchemaError = false;
		options.DataModel.SkipProceduresWithSchemaErrors = true;
		options.DataModel.GenerateProcedureResultAsList = false;
		options.DataModel.GenerateProcedureParameterDbType = true;
		options.DataModel.GenerateProcedureSync = true;
		options.DataModel.GenerateProcedureAsync = false;
		options.DataModel.GenerateSchemaAsType = false;
		options.DataModel.GenerateIEquatable = false;
		options.DataModel.GenerateFindExtensions = DataModel.FindTypes.None;
		options.DataModel.OrderFindParametersByColumnOrdinal = true;

		// code generation options
		options.CodeGeneration.EnableNullableReferenceTypes = false;
		options.CodeGeneration.SuppressMissingXmlDocWarnings = true;
		options.CodeGeneration.MarkAsAutoGenerated = false;
		options.CodeGeneration.ClassPerFile = false;
		options.CodeGeneration.Namespace = contextNamespace;

		return options;
	}

	public static (List<ExplorerItem> items, string sourceCode, IReadOnlyList<string> references) GetModel(IConnectionInfo cxInfo, ref string? contextNamespace, ref string contextName)
	{
		var references = new List<string>();

		var providerName = (string?)cxInfo.DriverData.Element(CX.ProviderName);
		var connectionString = cxInfo.DatabaseInfo.CustomCxString;
		var providerPath = (string?)cxInfo.DriverData.Element(CX.ProviderPath);
		var commandTimeout           = cxInfo.DriverData.ElementValueOrDefault(CX.CommandTimeout, str => str.ToInt32() ?? 0, 0);

		var settings = GetOptions(cxInfo, contextNamespace, contextName);

		var providerInfo     = ProviderHelper.GetProvider(providerName, providerPath);
		var provider         = providerInfo.GetDataProvider(connectionString);

		references.AddRange(providerInfo.GetAssemblyLocation(connectionString));

		using var db = new DataConnection(provider, connectionString);
		db.CommandTimeout = commandTimeout;
		var sqlBuilder = db.DataProvider.CreateSqlBuilder(db.MappingSchema);

		var language = LanguageProviders.CSharp;
		var interceptor = new ModelProviderInterceptor(sqlBuilder);
		var generator  = new Scaffolder(language, HumanizerNameConverter.Instance, settings, interceptor);
		var schemaProvider = new LegacySchemaProvider(db, settings.Schema, language);
		var dataModel  = generator.LoadDataModel(schemaProvider, schemaProvider);

		var files      = generator.GenerateCodeModel(
			sqlBuilder,
			dataModel,
			MetadataBuilders.GetAttributeBasedMetadataBuilder(generator.Language, sqlBuilder),
			SqlBoolEqualityConverter.Create(generator.Language),
			new DataModelAugmentor(language, language.TypeParser.Parse<LINQPadDataConnection>(), providerName, providerPath, connectionString, commandTimeout));

		var sourceCode = generator.GenerateSourceCode(dataModel, files)[0].Code;

		contextNamespace = dataModel.DataContext.Class.Namespace;
		contextName = dataModel.DataContext.Class.Name;
		return (interceptor.GetTree(), sourceCode, references);
	}
}
